function rhd = rhd_parse2headermat(rhd, varargin)
% RHD_PARSE2MAT Parse a single .rhd file into component parts. Organizes
% metadata of these parts in one matlab table and by default save these
% parts as .mat files (in the same location as the original .rhd file).
%
% SYNTAX
% rhd_parse2mat(rhd)
% rhd_parse2mat(__,Name,Value) 
% rhd = rhd_parse2mat(__)
%
%
% DESCRIPTION
% rhd_parse2mat(rhd) reads in the rhd struct, parses into component data
% variables named according to internal processes in the function, and
% saves each variable in the same location as the .rhd
% rhd_parse2mat(__,Name,Value) specifies properties using one or more 
% Name,Value pair arguments. For a list of properties, see Line Properties. Use this option with any of the input argument combinations in the previous syntaxes. Name-value pair settings apply to all the lines plotted.
% T = rhd_parse2mat(__) returns a metadata table where each row pertains to a
% single component variable extracted from the .rhd file struct. 
%
%
% INPUT ARGUMENTS
% rhd - struct
% this is a struct that is the output of the read_Intan.m function
% made by the neuroMechanist (see toolbox)
%
%
% OUTPUT ARGUMENTS
% rhd - matlab struct variable
% this is essentially the same struct that is read in by the "read_intan"
% function, just with time-series data removed from it, and instead with
% "dataPointer" field that has stored the path for loading individual
% channels of timeseries data. 
% 
%
% NAME-VALUE PAIR ARGUMENTS
% 'writefiles' - TF 
% true (default) | false
% Set this to control whether or not each component variable gets saved when you run this code 
% 'parsedDir' - character array
% user specifies the full path to a directory where parsed mat files
% generated by this function will be saved. (Ex: 'C:\someDirectory\)
% 
% TIPS
% Function for converting one .rhd "traditional" to many smaller files in 
% .mat format. For the type of recording that's running during the 
% experimental protocol, an .rhd % file with all recording info is 
% generated for every 1 min of recording.
% The idea is to parse out all relevant data into smaller chunks and save
% them as .mat files for ease of loading -- currently each file is pretty
% big and takes a while to load!
% Author: Ed Bello



%% Code

defaultwritefiles = true;
defaultparsedDir = rhd.path;
defaultSingleChannelFiles = true;

p = inputParser;
addRequired(p, 'rhd', @(x) isstruct(x));
addParameter(p, 'writefiles', defaultwritefiles, @(x) islogical(x));
addParameter(p, 'parsedDir', defaultparsedDir, @(x) ischar(x));
addParameter(p, 'singleChannelFiles', defaultSingleChannelFiles, @(x) islogical(x)); 
parse(p,rhd,varargin{:});
writefiles = p.Results.writefiles;
parsedDir = p.Results.parsedDir;
singleChannelFiles = p.Results.singleChannelFiles;


% enforce the last char being a forward slash
if ~strcmp(parsedDir(end), '\'), parsedDir = [parsedDir '\']; end
    
pn = parsedDir;
rhd.parsedDataPointer = struct;

idxP = 1; % initialize the dataPointer field index, to be iterated for each channel of timeseries data



%% save individual channels from "amplifer_data", "aux input data", and 
% "board_dig_in_data" and remove them from the header:

dataTypeFields = {'amplifier_data', 'aux_input_data', 'board_dig_in_data'};
metadataFields = {'amplifier_channels', 'aux_input_channels', ...
    'board_dig_in_channels'}; % make sure this is same length as dataTypeFields

nTypes = length(dataTypeFields);
for iType = 1:nTypes
    
    dataType = dataTypeFields{iType};
    metadata = metadataFields{iType};

    if singleChannelFiles
        nChans = size(rhd.(dataType),1);
        for iCh = 1:nChans

            data = rhd.(dataType)(iCh,:);
            chanLabel = rhd.(metadata)(iCh).native_channel_name;
            parsedFilename = [rhd.filename dataType chanLabel '.mat'];

            rhd.parsedDataPointer(idxP).parsedFilename = parsedFilename;  
            rhd.parsedDataPointer(idxP).dataType = dataType;
            rhd.parsedDataPointer(idxP).chanLabel = chanLabel;
            rhd.parsedDataPointer(idxP).nsamples = length(data);
            rhd.parsedDataPointer(idxP).metadataField = metadata;
            rhd.parsedDataPointer(idxP).metadataFieldIdx = iCh;

            if writefiles
                subfun_savefile(pn, parsedFilename, data)
                disp(['Saved ' parsedFilename])

            end

            idxP = idxP+1;

        end
    
    else
%         data = rhd.(dataType)(iCh,:);
%         chanLabel = rhd.(metadata)(iCh).native_channel_name;
%         parsedFilename = [rhd.filename dataType chanLabel '.mat'];
        data = rhd.(dataType);
        chanLabel = '';
        parsedFilename = [rhd.filename dataType chanLabel '.mat'];
        

%         rhd.parsedDataPointer(idxP).parsedFilename = parsedFilename;  
%         rhd.parsedDataPointer(idxP).dataType = dataType;
%         rhd.parsedDataPointer(idxP).chanLabel = chanLabel;
%         rhd.parsedDataPointer(idxP).nsamples = length(data);
%         rhd.parsedDataPointer(idxP).metadataField = metadata;
%         rhd.parsedDataPointer(idxP).metadataFieldIdx = iCh;

        if writefiles
            subfun_savefile(pn, parsedFilename, data)
            disp(['Saved ' parsedFilename])

        end

        idxP = idxP+1;
        
    end
    rhd = rmfield(rhd, dataType);

end



%% save individual channels from "t_amplifier" , "t_aux_input", and 
% "t_dig" and remove them from the header:

dataTypeFields = {'t_amplifier', 't_aux_input', 't_dig'};

nTypes = length(dataTypeFields);
for iType = 1:nTypes
    
    dataType = dataTypeFields{iType};
    
    nChans = size(rhd.(dataType),1);
    for iCh = 1:nChans

        data = rhd.(dataType)(iCh,:);
        parsedFilename = [rhd.filename dataType '.mat'];

        rhd.parsedDataPointer(idxP).parsedFilename = parsedFilename;  
        rhd.parsedDataPointer(idxP).dataType = dataType;
        rhd.parsedDataPointer(idxP).nsamples = length(data);

        if writefiles
            subfun_savefile(pn, parsedFilename, data)
            disp(['Saved ' parsedFilename])


        end

        idxP = idxP+1;  

    end
    rhd = rmfield(rhd, dataType);
    
end



%% save timeseries-reduced rhd struct as now a header file 

dataType = 'header';
parsedFilename = [rhd.filename dataType '.mat'];

rhd.parsedDataPointer(idxP).parsedFilename = parsedFilename;  
rhd.parsedDataPointer(idxP).dataType = dataType;

if writefiles
    try
        save([pn parsedFilename], 'rhd');

    catch ME
        % handle the exception of the specified parent directory not yet
        % existing as specified
        if strcmp(ME.identifier, 'MATLAB:save:noParentDir')
            warning('User-specified path for "parsedDir" does not yet exist, creating now...');
            mkdir(pn);
            save([pn parsedFilename], 'rhd');

        else
            error(ME.message);

        end


    end
    
    disp(['Saved ' parsedFilename])
end

end

%% SUB-FUNCTIONS

function subfun_savefile(pn, parsedFilename, data)

try
    save([pn parsedFilename], 'data');
    
catch ME
    % handle the exception of the specified parent directory not yet
    % existing as specified
    if strcmp(ME.identifier, 'MATLAB:save:noParentDir')
        warning('User-specified path for "parsedDir" does not yet exist, creating now...');
        mkdir(pn);
        save([pn parsedFilename], 'data');

    else
        error(ME.message);

    end


end


end


